---
title: "Best Ball Win prob/projection"
author: "Harrison Stanton"
date: "2025-01-07"
output: html_document
---
 
Jake Tonges not showing up in ff

To do list (9/20)
1. Change from 4 quantiles just to upper and lower (1st and 99th?)
2. continue to be diligent on updating rosters. this is really going to affect my projections, even more than Sleeper's
3. Work on the app!!
4. Continue to investigate where my projections fall short that Sleeper's don't
5. Add the 50% after 4 games, 50% over next 8 for rookies
6. add in something so I can't run the sim_two function if a team name is wrong or if no players are in the team 
7. Check how rookies not in that sample look (like kyle williams)

For next year:
1. figure out how to add in bye weeks
2. figure out how to add in usage so that I don't have to completely delete players
```{r, message=FALSE}
library(tidyverse)
library(dplyr)
library(rsconnect)
library(kableExtra)
library(nflfastR)
library(nflreadr)
library(stats)
library(Hmisc)
library(readr)
library(scales)
```


```{r, message=FALSE}
#this is the rookies who were drafted in the first 3 rounds of rookie drafts from 2015-2023
#source - https://fantasyfootballcalculator.com/adp/rookie/12-team/all/2024
#added our own rookie draft for 2024 since it didn't have that data
ADP_data <- read_csv("Rookies drafted 2015-2025 - Sheet1.csv") %>%
  rename(full_name = Name)
```


```{r, message=FALSE}
load("All_Players_Database.RData")
load("RookieDatabase.RData")
Rookie_database <- Rookie_database %>% arrange(full_name)
```

#Data cleaning
Think this is where I was losing my dummy rookie players. just changed na.rm to false instead of true.
This is going to be annoying as crap trying to figure out how to keep my dummy rookies in this list. I feel like the easiest thing might just be to add the mean score for each bucket as their average, but that's going to change all the time. 

This should fix the rookie placeholder stuff
```{r}
Rookie_database <- Rookie_database %>%
  group_by(position, bucket) %>%
  mutate(
    deviation = sd(total_fantasy_points, na.rm = TRUE),
    mean = mean(total_fantasy_points, na.rm = TRUE)
  ) %>%
  ungroup() %>%
  filter(
    is.na(total_fantasy_points) |
    (total_fantasy_points <= mean + 3 * deviation &
     total_fantasy_points >= mean - 3 * deviation &
     total_fantasy_points >= 0)
  )
```


#adding bucket to/pick to ff
Potentially change slide_head to 16 instead (if they're in a championship, i only want this season stats.)
```{r}
ff <- All_Players_Database %>% 
  filter(season == "2023" | season == "2025" | season == "2024" | season == "0") %>%
  group_by(player_id) %>%
  arrange(desc(season), desc(week)) %>%
  #17?
  slice_head(n=16) %>%
  ungroup()
```

```{r}
ff <- ff %>%
  group_by(player_id) %>%
  mutate(
    deviation = sd(total_fantasy_points, na.rm = TRUE),
    mean = mean(total_fantasy_points, na.rm = TRUE)
  ) %>%
  ungroup()
```

Manually added Tonges' deviation so he didn't get filtered out. 
```{r}
ff <- ff %>%
  mutate(
    deviation =
      if_else(player_id == "00-0037112", 5, deviation)
  )
```



Might need to add 
```{r}
ff <- ff %>%
  filter((is.rookie == FALSE & total_fantasy_points <= mean + 3 * deviation & total_fantasy_points >= mean - 3 * deviation) | is.rookie == TRUE)
```




#Adding bucket to ff
This is very important still, i can't just take this off. ff is being used when i pass into the sim_two, which needs bucket
```{r}
temp <- Rookie_database %>%
  distinct(player_id, .keep_all = TRUE) %>%
  select(player_id, bucket)
```


```{r}
ff <- left_join(ff, temp, by = "player_id")
```

Included this so I didn't double count rookie's scores when generating the weighted quantile
```{r}
Rookie_database <- Rookie_database %>%
  filter(season != 2025)
```





#ChatGPT weighted quantile
```{r}
weighted_quantile <- function(x, w, probs = c(0.25, 0.5, 0.75)) {
  # Remove NAs
  keep <- !is.na(x) & !is.na(w)
  x <- x[keep]
  w <- w[keep]

  # Sort x and w by x
  ord <- order(x)
  x <- x[ord]
  w <- w[ord]

  # Normalize weights
  w <- w / sum(w)
  cum_w <- cumsum(w)

  # Interpolate
  sapply(probs, function(p) {
    if (p <= cum_w[1]) return(x[1])
    if (p >= cum_w[length(cum_w)]) return(x[length(x)])
    idx <- which(cum_w >= p)[1]
    if (cum_w[idx] == p || idx == 1) {
      return(x[idx])
    } else {
      x1 <- x[idx - 1]
      x2 <- x[idx]
      w1 <- cum_w[idx - 1]
      w2 <- cum_w[idx]
      # Linear interpolation
      return(x1 + (p - w1) / (w2 - w1) * (x2 - x1))
    }
  })
}
```


code to view my projections

The projections that seem to always be the most off are rookies and old guys who changed roles.
Is my way of projecting rookies even better? or should I really just have this sucker weight rookie scores way more than it does? Like maybe even by game 3 have like 2/3 weighted to rookies? but then the malik nabers huge game still is a problem. Or could i just have it be like 2/3 weight the whole time, and then just a jump after like 6 games to like 90% that player's scores, then 100% after 12
  - Think this sounds right tbh. Test this tonight. 
```{r}
avg_3 <- scores3 %>%
  filter(player_id %in% Rookie_team) %>% 
  group_by(player_id) %>%
  summarise(
    lin_avg = mean(score)
  ) %>%
  inner_join(ff %>% select(player_id, full_name) %>% distinct(player_id, .keep_all = TRUE), by = "player_id") %>%
  arrange(full_name) %>%
  view()
```


#Simulate two with non-rookie, <12 GP distinction
This works correctly 9/4
Changed this on 9/18 to weight rookie scores more heavily early on. made it 40% over the first 4. This still isn't perfect (ex. matthew golden too high, colston loveland too high) but from an eye test for rookies it definitely looks better.

Another thought that I had was if they hadn't played yet in 2025 minus QBs and Chris Godwin, what if I docked their potential scores by 90%? Then teams like Luke's wouldn't be so dumb and over project.
Jordan Mason, Trey Benson, Emari Demercado
```{r}
increased_roles <- c("00-0037525", "00-0039921", "00-0038705")
```

brian robinson, tank bigsby, adam thielen, Jonnu Smith, Najee Harris
```{r}
decreased_roles <- c("00-0037746", "00-0038555", "00-0030035", "00-0033858", "00-0036893")
```


I don't think this idea ^^ will work, but I think I need to find ways to dock some of these teams tbh. 
This is better than it has been with increased/decreased role and rookie tweaks. going to try this, then try it in nerfed and see what happens 
```{r}
sim_two <- function(ff, team_1, team_2){
  player_ids_vector <- c()
  all_player_scores_list <- list()
  ff <- ff %>%
    select(season, week, full_name, player_id, season_player_id, full_name, position, total_fantasy_points, is.rookie, GP, bucket) %>%
    arrange(full_name)
  
  player_lookup <- ff %>%
    distinct(player_id, .keep_all = TRUE) %>%
    select(player_id, position, full_name)
  
  subset_df <- ff %>%
    filter(player_id %in% c(team_1, team_2)) 
  
  #could probably add a secondary thing right here.
  #separate the names that are user generated, put then into a new list
  #use that list at the end, basically calling the function I already made.
  #going to need a dataframe with 3 columns: score, position, team. 
  
  # Keep only user added player scores
  # valid_players <- player[grepl("WR,|RB,|TE,|QB,", player)]
  # valid_players %>% 
  #   mutate(team)
  
  
  ids <- c(team_1, team_2)
  teams <- c(rep("Team 1", length(team_1)),
           rep("Team 2", length(team_2)))
  
  player_info <- tibble(player_id = ids, team = teams) %>%
    left_join(player_lookup, by = "player_id")
  
  
  n_obs <- 15000
  
  
  full_ids <- rep(player_info$player_id, each = n_obs)
  full_positions <- rep(player_info$position, each = n_obs)
  full_names <- rep(player_info$full_name, each = n_obs)
  full_observations <- rep(1:n_obs, length(ids))
  
  
  for(i in 1:length(ids)){
    #vector containing generated scores for one individual
    #think chat cut this too
    #individual_scores <- c()
    #df with only the one player's stats
    player <- subset_df %>%
      filter(player_id == ids[[i]]) %>%
      arrange(desc(season), desc(week))
    
    is_rookie <- player$is.rookie[1]
    gp_max <- max(player$GP)

    #where if they're a rookie and have played fewer than 12 games, do the weighted quantile stuff, otherwise normal
    #quantile for said one player
    #trying this without rookie stuff at all 
    
     if(is_rookie && gp_max < 12){
         player_position <- player$position[1]
         player_bucket <- player$bucket[1]

         #scores from the same position and bucket as the rookie we're looking at
         position_bucket_scores <- Rookie_database %>%
         filter(position == player_position & bucket == player_bucket) %>%
         pull(total_fantasy_points)

         #player's individual scores
         player_scores <- player$total_fantasy_points

         #number of individual's scores
         rookie_games <- length(player_scores)
         #number of just bucket player's scores
         bucket_games <- length(position_bucket_scores)


         #This is implementing piecewise function instead to slow down weight of rookie's scores initially
         #Messing with this quite a bit
        if(gp_max < 8){
           p <- .8
         } else {
           p <- 0.9
         }
         rookie_weights <- rep(p / rookie_games, rookie_games)
         bucket_weights <- rep((1 - p) / bucket_games, bucket_games)
         combined_weights <- c(rookie_weights, bucket_weights)

         #If I change how many quantiles, would have to go right here
         player_quantile <- weighted_quantile(
           c(player_scores, position_bucket_scores),
           combined_weights,
           probs = c(.10, .90)
           )

     #think I'm going to need one more else if loop here to detect if the player is of added score format.
     } else {
          #changed quantile to just 10th and 90th
          player_quantile <- quantile(player$total_fantasy_points, probs = c(.075, .875))
      }
    
      #individual_scores <- numeric(15000)
      rng <- runif(n_obs)
      scores <- numeric(n_obs)
      
          # if(!is_rookie && gp_max < 12){
              lower <- unname(player_quantile[1])
              upper <- unname(player_quantile[2])
              scores[rng < .075] <- lower
              scores[rng >= .875] <- upper
              mid_idx <- rng >= .075 & rng < .875
              scores[mid_idx] <- lower + (rng[mid_idx] - 0.075) * (upper - lower) / 0.8
         # attempting to just have the 10-90 quantiles.
         # } else{
         #    bins <- cut(rng, breaks = c(0, 0.25, 0.5, 0.75, 1), labels = FALSE)
         #    lower <- unname(player_quantile[bins])
         #    upper <- unname(player_quantile[bins + 1])
         #    #Change quantile
         #    span <- c(0.25, 0.25, 0.25, 0.25)[bins] # segment width
         #    #Change quantile 
         #    offset <- c(0.00, 0.25, 0.50, 0.75)[bins] # segment start
         #    same_val <- upper == lower
         #    scores[same_val] <- lower[same_val]
         #    scores[!same_val] <- lower[!same_val] + 
         #                         (rng[!same_val] - offset[!same_val]) * 
         #                         (upper[!same_val] - lower[!same_val]) / span[!same_val]
         # }
      all_player_scores_list[[i]] <- scores
  } 

  
  
  scores <- tibble(
    observation = full_observations,
    player_id = full_ids,
    team = rep(player_info$team, each = n_obs),
    score = unlist(all_player_scores_list),
    full_name = full_names,
    position = full_positions
  )
  
  scores <- scores %>%
    mutate(
      score = 
        case_when(
          player_id %in% decreased_roles ~ score * .35,
          player_id %in% increased_roles ~ score * 1.75,
          TRUE ~ score
        )
    )
        
    
  #think right here is where i'll add my call to add player

  return(scores)
}

```

Think this is better for right now. Obviously, really stupid that this is how I'm accounting for the slower pace and less scoring by just shifting what I'm doing, but this is definitely closer to what is happening than we're seeing from my above model. If i was projecting target share/scoring that would definitely help, but this is my patchwork way of fixing that. should really view player projections for this right now too. 

this looks better, gonna have to tweak some of the numbers, specifically the increased_roles one.
```{r}
 scores3 <- scores %>%
    mutate(
      score = 
        case_when(
          player_id %in% decreased_roles ~ score * .25,
          player_id %in% increased_roles ~ score * 1.75,
          TRUE ~ score
        )
    ) %>%
  filter(player_id %in% c(decreased_roles, increased_roles))
```


```{r}
nerfed_sim_two <- function(ff, team_1, team_2){
  player_ids_vector <- c()
  all_player_scores_list <- list()
  ff <- ff %>%
    select(season, week, full_name, player_id, season_player_id, full_name, position, total_fantasy_points, is.rookie, GP, bucket) %>%
    arrange(full_name)
  
  player_lookup <- ff %>%
    distinct(player_id, .keep_all = TRUE) %>%
    select(player_id, position, full_name)
  
  subset_df <- ff %>%
    filter(player_id %in% c(team_1, team_2)) 
  
  #could probably add a secondary thing right here.
  #separate the names that are user generated, put then into a new list
  #use that list at the end, basically calling the function I already made.
  #going to need a dataframe with 3 columns: score, position, team. 
  
  # Keep only user added player scores
  # valid_players <- player[grepl("WR,|RB,|TE,|QB,", player)]
  # valid_players %>% 
  #   mutate(team)
  
  
  ids <- c(team_1, team_2)
  teams <- c(rep("Team 1", length(team_1)),
           rep("Team 2", length(team_2)))
  
  player_info <- tibble(player_id = ids, team = teams) %>%
    left_join(player_lookup, by = "player_id")
  
  
  n_obs <- 15000
  
  
  full_ids <- rep(player_info$player_id, each = n_obs)
  full_positions <- rep(player_info$position, each = n_obs)
  full_names <- rep(player_info$full_name, each = n_obs)
  full_observations <- rep(1:n_obs, length(ids))
  
  
  for(i in 1:length(ids)){
    #vector containing generated scores for one individual
    #think chat cut this too
    #individual_scores <- c()
    #df with only the one player's stats
    player <- subset_df %>%
      filter(player_id == ids[[i]]) %>%
      arrange(desc(season), desc(week))
    
    is_rookie <- player$is.rookie[1]
    gp_max <- max(player$GP)

    #where if they're a rookie and have played fewer than 12 games, do the weighted quantile stuff, otherwise normal
    #quantile for said one player
      if(is_rookie && gp_max < 12){
          player_position <- player$position[1]
          player_bucket <- player$bucket[1]
          
          #scores from the same position and bucket as the rookie we're looking at
          position_bucket_scores <- Rookie_database %>% 
          filter(position == player_position & bucket == player_bucket) %>%
          pull(total_fantasy_points)
          
          #player's individual scores
          player_scores <- player$total_fantasy_points
          
          #number of individual's scores
          rookie_games <- length(player_scores)
          #number of just bucket player's scores
          bucket_games <- length(position_bucket_scores)
          
          
          #This is implementing piecewise function instead to slow down weight of rookie's scores initially
          #want to change this to 50 after 4 instead, think that would be better. try after week 3 though.
          if(gp_max < 4){
            p <- gp_max * .5/4           
          } else {
            p <- 0.5 + ((gp_max - 4) / 8) * 0.5
          }
          rookie_weights <- rep(p / rookie_games, rookie_games)
          bucket_weights <- rep((1 - p) / bucket_games, bucket_games)
          combined_weights <- c(rookie_weights, bucket_weights)
            
          #If I change how many quantiles, would have to go right here
          player_quantile <- weighted_quantile(
            c(player_scores, position_bucket_scores),
            combined_weights,
            #just gotta make these upper and lower bounds a variable, it's obnoxious to change it in so many places
            probs = c(.05, .85)
            )
          
      # }  else if (!is_rookie & gp_max < 12){
      #       
      #       #think I'm going to need one more else if loop here to detect if the player is of added score format.
      } else {
          #changed quantile to just 10th and 90th
          player_quantile <- quantile(player$total_fantasy_points, probs = c(.05, .85))
      }
    
      #individual_scores <- numeric(15000)
      rng <- runif(n_obs)
      scores <- numeric(n_obs)
      
          # if(!is_rookie && gp_max < 12){
              lower <- unname(player_quantile[1])
              upper <- unname(player_quantile[2])
              scores[rng < .05] <- lower
              scores[rng >= .85] <- upper
              mid_idx <- rng >= .05 & rng < .85
              scores[mid_idx] <- lower + (rng[mid_idx] - 0.05) * (upper - lower) / 0.8

      all_player_scores_list[[i]] <- scores
  } 

  
  
  scores <- tibble(
    observation = full_observations,
    player_id = full_ids,
    team = rep(player_info$team, each = n_obs),
    score = unlist(all_player_scores_list),
    full_name = full_names,
    position = full_positions
  )
  
  #think right here is where i'll add my call to add player

  return(scores)
}
```
#adding players update, two teams
Think I don't want to combine optimize and this. Think I'd just wanna do optimize_teams(add_player()) instead
This is so close to being nice, but I might need them to add a player name or something. Like if you add two WRs right now to the same team, it's gonna break if they both should hit your lineup. How can I make it so that each time you hit this button, it just increases the player_id number? 

ChatGPT vectorized version
```{r}
add_score <- function(user_score, user_position, user_team, scores) {
  n <- length(user_score)
  
  observation <- seq_len(15000)          # stays same size as your original
  fake_id <- as.character(-sample.int(1e9, n))  # one id per row
  
  temp <- tibble(
    player_id = fake_id,
    score     = user_score,
    team      = user_team,
    full_name = paste0(user_position, ", ", user_score, " pts"),
    position  = user_position
  )
  
  temp <- cbind(observation, temp)
  #so this is already going to have access to the df I created in sim_two. That makes sense, don't 100% know if that'll work or not.
  scores <- bind_rows(scores, temp)
  
  return(scores)
}
```



Workflow: Run both chunks where I have commented in the top of sim_two(). Then need to remove these user_added_players from team1, team2 (just use same grepl, but !grepl()). Then, run add scores after scores is already created, return that sucker

*IMPORTANT*
team1[!grepl("WR,|RB,|TE,|QB,", team1)] - Code to run on team1 and team2 to remove user added stuff. 

```{r}
  #Keep only user added player scores from ids vectors
  user_added_players <- as_tibble(c(team1, team2)[grepl("WR,|RB,|TE,|QB,", c(team1, team2))])
  #add teams to df, this should be what I can pass to add_scores
  user_added_players <- user_added_players %>%
    mutate(
      team = ifelse(value %in% team1, "Team 1", "Team 2")
      )
```

ChatGPT vectorized version.
```{r}
user_added_players <- tibble(raw = valid_players) %>%
  mutate(
    team = ifelse(raw %in% Team_1, "Team 1", "Team 2")
  ) %>%
  extract(raw, into = c("position", "points"),
          regex = "([^,]+), ([0-9]+) pts",
          convert = TRUE)

user_added_players
```



This is by far the slowest part, but idk if there's a better way to do this tbh. 
```{r}
optimize_teams <- function(scores) {


  df <- scores %>%
    arrange(observation, desc(score))
  

  df <- df %>%
    group_by(observation, team) %>%
    mutate(
      qb_rank = cumsum(position == "QB"),
      rb_rank = cumsum(position == "RB"),
      wr_rank = cumsum(position == "WR"),
      te_rank = cumsum(position == "TE")
    ) %>%
    ungroup()
  

  starters <- df %>%
    filter(
      (position == "QB" & qb_rank <= 1) |
      (position == "RB" & rb_rank <= 2) |
      (position == "WR" & wr_rank <= 2) |
      (position == "TE" & te_rank <= 1)
    )
  
  picked_ids <- starters %>% select(observation, team, player_id)
  

  flex <- df %>%
    filter(position %in% c("RB", "WR", "TE")) %>%
    anti_join(picked_ids, by = c("observation", "team", "player_id")) %>%
    group_by(observation, team) %>%
    slice_head(n = 2) %>%
    ungroup()
  
  picked_ids <- bind_rows(picked_ids, flex %>% select(observation, team, player_id))
  
  superflex <- df %>%
    anti_join(picked_ids, by = c("observation", "team", "player_id")) %>%
    group_by(observation, team) %>%
    slice_head(n = 1) %>%
    ungroup()
  

  optimized_team <- bind_rows(starters, flex, superflex) %>%
    arrange(observation, team, desc(score)) %>%
    select(observation, player_id, team, score, full_name, position)
  

  obs_totals <- optimized_team %>%
    group_by(observation, team) %>%
    summarise(total = sum(score, na.rm = TRUE), .groups = "drop") %>%
    pivot_wider(names_from = team, values_from = total) %>%
    mutate(
      winner = if_else(`Team 1` > `Team 2`, "Team 1", "Team 2")
    )
  
  return(obs_totals)
}
```


Code for the labels of the win prob graph. 
```{r}
avg_scores <- obs_totals %>%
  summarise(
    team1_avg = mean(`Team 1`, na.rm = TRUE),
    team2_avg = mean(`Team 2`, na.rm = TRUE)
  )
```



#win prob graph attempt
This looks complete, I'm happy with this.
```{r}
optimal %>%
  count(winner) %>%
  mutate(
    winner = factor(winner, levels = c("Team 2", "Team 1")),
    label_y = ((15000 - n) + .5 * n)/15000
    ) %>%
   ggplot(aes(x = 1, y = n, fill = winner)) +
        geom_bar(stat = "identity", position = "fill") +
        scale_fill_brewer(palette = "Set1",
                          name = "Team") + 
        guides(fill = guide_legend(reverse = TRUE)) +  
        coord_flip() +
        scale_y_continuous(labels = scales::percent_format(accuracy = 1)) +
        labs(x = NULL, title = "Win Probability", y = NULL) +
        theme(
          plot.title = element_text(size = 24, hjust = 0.5),
          axis.title = element_text(size = 18), 
          axis.text.x = element_text(size = 14),
          legend.title = element_text(size = 16), 
          legend.text = element_text(size = 14),
          plot.caption = element_text(size = 14, face = "italic"),
          axis.text.y = element_blank()          
        ) +
        geom_text(aes(y = label_y, label = paste0(round(n/15000, 2) * 100, "%")), color = 'white', size = 5)
```





**IMPORTANT**
If i wanna compare the two like this says, think it might be easiest to just do this in this unpublished shiny app. This way. I can easily just say week < 2 or whatever, and adjust everyone's teams fairly quickly too. 

```{r}
optimal %>%
  count(winner) %>%
  mutate(
    winner = factor(winner, levels = c("Team 2", "Team 1")),
    win_prob = round(n / 15000, 2) * 100,
    #this label y is so broken. need to fix this tomorrow.
    label_y = ((15000 - n) + .5 * n)/15000
    ) 
```



#compare tab
This is what is going to output below the graph in the middle panel.
```{r}
optimal %>%
  summarise(
    Team_1_score = round(mean(`Team 1`)),
    Team_2_score = round(mean(`Team 2`))
  ) 

```




name_list is the players and ids in the same df. Think this is going to need to be a global variable. Want to be able to use this right away when people input teams. 

need to pass vector of names, pull ids, then do the same stuff. think that's easier. going to have to change the UI to include roster, have it be clickable as well.
```{r}
#this is something I'm going to need for all the dropdowns as well. Might have to use match, idek how it's all going to work tbh. Need you to be able to input a player name from a dropdown and then have my ish switch to a player_id instead.
remove_player <- function(player_name){
  name_list <- ff %>%
    select(full_name, player_id) %>%
    distinct(player_id, .keep_all = TRUE)
  
  user_id <- name_list %>%
    filter(full_name == player_name) %>%
    pull(player_id)
  
  #this is basically what it's going to be
  scores <- scores %>% 
    filter(player_id != user_id)
  
  return(scores)
}
```

For clearing out stuff if someone straight up just wants to start over
```{r}
clear_all <- function(){
  rm(scores, optimal, team_1, team_2, envir = .GlobalEnv)
}
```

Add player to roster
This should have a dropdown, like a data validation vibe, where you can only put team 1 or team 2
Also, going to have to include team_1 and team_2 in my global environment when I make the app. Basically just that initial dropdown right away have it be team_1 or team_2. probably will have to change the variable names inside the function to something like input$team_1
```{r}
add_player <- function(player, team){
  if(team == "Team 1"){
    team <- team_1
  } else {
    team <- team_2
  }
  team <- c(team, player)
  
  return(team)
}
```


So how would this work as a user? it'd be:
1. select teams
 a. have this immediately generate scores to save time (use the reactive part here)
2. add player scores/remove players
3. optimize -> if at all possible, only run optimize once. this thing takes forever.
4. graph

this is going to take a hot sec to run i'm ngl, but it's gonna be pretty dope when it does

# This is what the app is going to be, maybe plus or minus the add/remove players
I don't think this is the way it should work. optimze + graph + sim should be separated. if i did it like this, then add and remove player wouldn't even work. 

workflow:
1. pick team
2. add or remove players from team
3. simulate
4. add scores from the week
5. optimize + graph (this can be the same step. think that's totally fine.)

Labels on this graph got messed up. Don't know where it went wrong, feel like that might not be a right now problem though. 
```{r}
optimize_teams(scores) %>%
  count(winner) %>%
  mutate(
    winner = factor(winner, levels = c("Team 2", "Team 1")),
    label_y = ((15000 - n) + .5 * n)/15000
    ) %>%
   ggplot(aes(x = 1, y = n, fill = winner)) +
        geom_bar(stat = "identity", position = "fill") +
        scale_fill_brewer(palette = "Set1",
                          name = "Team") + 
        guides(fill = guide_legend(reverse = TRUE)) +  
        coord_flip() +
        scale_y_continuous(labels = scales::percent_format(accuracy = 1)) +
        labs(x = NULL, title = "Win Probability", y = NULL) +
        theme(
          plot.title = element_text(size = 24, hjust = 0.5),
          axis.title = element_text(size = 18), 
          axis.text.x = element_text(size = 14),
          legend.title = element_text(size = 16), 
          legend.text = element_text(size = 14),
          plot.caption = element_text(size = 14, face = "italic"),
          axis.text.y = element_blank()          
        ) +
        geom_text(aes(y = label_y, label = paste0(round(n/15000, 2) * 100, "%")), color = 'white', size = 5)
```


Next steps for my project:
6/30
1. Finish data entry for rookie non stat recording weeks
2. Need to finish rookie quantile projection. Think because of the lack of data, acceptable to eye ball best relationship, definitely wanna use some log slowly increasing function
3. Make linear_sim(), optimize_team() work for 2 teams at once (if they put nothing for team two, pass along empty string and make it a 100% win prob)
4. Make win prob/compare! shouldn't be too bad, especially once linear sim and optimize functions work for both teams
5. Make the shiny app! (How am I gonna do rookies? Wait till week 2?)
6. Make a manual lever to pull for when someone's role dramatically changes, like Raheem Mostert from 2023 to 2024 (points per touch * # of extra touches + projection)

Biggest problems i foresee with my projection:
1. handcuff players 
  what happens when KW3 goes down and my charb projection stays the same? obviously that's not right
      Best guess right now: add a term - fp/touch * normal dist centered around touches vacqted. going to have to
      manually input for guys (i think i can guesstimate how a backfield is gonna be split than actually have 
      a mathematical reasoning behind it)
        - need to test using 2023 data on 2024 season. 
2. rookies
  what happens when 3 games into the season, it's obvious that BTJ and Ladd are better than their quadrant but I'm still
  grouping by their draft capital? Is there some way I can weight recent production more than the past, especially for 
  young guys? 
    Hmisc:wtd.quantile() - weight the persons scores equally to the scores of rookies in the same bucket. I think this
    will be a much more effective way to estimate their scores, but I'm gonna try it using 2023 data on 2024
    season to see what the best method is

**Important**
When I'm telling everyone how to use this, need to make sure that they don't add a bunch of ppl who are hurt/backup QBs. If they're not gonna play, just don't add them. I don't have time to update them all every week, but I'll update handcuff running backs and stuff like that where I can

Going to need a remove player from list function, and also a clear_all function for the shiny app.


Linear sim only gonna work for full team... observation numbers get messed up otherwise. 3 observations for each player when I used the 

#making objects for the app
This should probably be saved for all the lists/dropdowns
```{r}
names_and_ids <- All_Players_Database %>%
  filter(season %in% c(0, 2025, 2023, 2024)) %>%
  filter(position %in% c("QB", "WR", "TE", "RB")) %>%
  arrange(desc(total_fantasy_points)) %>%
  select(full_name, player_id) %>%
  filter(!is.na(full_name))
```

How I want to display each team. Have them all stored as their IDs, but then just keep everything in terms of names using names_and_ids
```{r}
names_and_ids %>%
  filter(player_id %in% Jared_alt) %>%
  pull(full_name)
```

#teams
Left out Coker (IR) ("00-0039491"), MarShawn Lloyd, IR ("00-0039811"), Dillon Gabriel, not playing ("00-0040704"), jayden reed IR (00-0039146"), Keaton mitchell (not playing, 00-0038454"), Jarquez Hunter (not playing), Charbonnet (hurt, "00-0039165")
```{r}
Team_Stanton <- c("00-0036389", "00-0039893", "00-0038543", "00-0037809", "00-0036912", "00-0037816", "00-0036264", "00-0040734", "00-0040676", "00-0040126", "00-0037545", "00-0040663", "00-0034270", "00-0040648", "00-0038951", "00-0040131", "00-0040138", "00-0039798")
```

Left out Jaylen Wright, IR ("00-0039874"), Riley Leonard (not gonna play, , "1-R-QB5"), JJ McCarthy (hurt, "00-0039923")
```{r}
Team_Johnson <- c("00-0039732", "00-0036555", "00-0040242", "00-0036322", "00-0039337", "00-0038933", "00-0037740", "00-0039894", "00-0035710", "00-0039376", "00-0039901", "00-0038935", "00-0036139", "00-0040739", "00-0039868", "00-0032950", "00-0039424", "00-0040729", "00-0039912", "00-0040715", "00-0040242", "00-0033955")
```

Left out jimmy g, jordan addison, Tank Dell (00-0038977), Kendrick Bourne (not on team, 00-0033307), "00-0039384" (tracey injured)
```{r}
Team_Snyder <- c("00-0034857", "00-0040122", "00-0038134", "00-0035676", "00-0036410", "00-0039338", "00-0039064", "00-0034796", "00-0037228", "00-0036997", "00-0034829", "00-0036970", "00-0036626", "00-0040735", "00-0037291", "00-0040669", "00-0035644", "00-0039355", "00-0033307", "00-0038705", "00-0040189", "00-0038994")
```

Deleted Burrow ("00-0036442"), added Jake Browning, Left off Aiyuk
```{r}
Team_Kloth <- c("00-0036442", "00-0038542", "00-0038597", "00-0034775", "00-0031408", "00-0036252", "00-0035229", "00-0039040", "00-0038120", "00-0034855", "00-0030565", "00-0037239", "00-0038996", "00-0030279", "00-0038608", "00-0033110", "00-0036875", "00-0037664", "00-0038117", "00-0040170", "00-0038563", "00-0031544", "00-0035100", "00-0030035")
```

Leaving out ARich, milroe, kirk add them back in if they play
need to change Roman Wilson, JJ McCarthy rookie years to now for calculation purposes. 

left out milroe ("00-0040673"), gabe davis ("00-0036196"), russell wilson ("00-0029263"), najee ("00-0036893"), ceedee ("00-0036358")
```{r}
Team_Weiner <- c("00-0033077", "00-0033906", "00-0036158", "00-0036407", "00-0030506", "00-0036613", "00-0036973", "00-0026498", "00-0034869", "00-0030061", "00-0037525", "00-0033923", "00-0033858", "00-0039794",  "00-0040164", "00-0038393")
```

Left Joe Milton out, need to make last year his rookie year in All Players Database. Left out Winston, Malachi Corley too
Roschon (00-0039021)
```{r}
Team_Chesney <- c("00-0039163", "00-0034791", "00-0034827", "00-0037240", "00-0036290", "00-0039916", "00-0037247", "00-0038979", "00-0040130", "00-0030564", "00-0039793", "00-0033282", "00-0034159", "00-0037666", "00-0033375", "00-0034407", "00-0037741", "00-0036328", "00-0036182", "00-0033857", "00-0037539")
```

 jalen mcmilaln, Quinn Ewers, Jonothan Brooks (IR), MARIOTA IN LINEUP
```{r}
Team_Hamm <- c("00-0036355", "00-0040198", "00-0038551", "00-0040667", "00-0039065", "00-0039356", "00-0038621", "00-0036550", "00-0036988", "00-0040581", "00-0039751", "00-0039144", "00-0040644", "00-0040134", "00-0039890", "00-0040009", "00-0038104", "00-0039907", "00-0040582")
```

Left off Sheduer (not gonna play), tyrod taylor ("00-0028118") added him because fields was hurt ("00-0036945"), guerrendo ("00-0039363")
```{r}
Team_Downing <- c("00-0033873", "00-0033280", "00-0036223", "00-0036900", "00-0035659", "00-0033885", "00-0037248", "00-0034348", "00-0026158", "00-0039917", "00-0031381", "00-0034837", "00-0037197", "00-0036275", "00-0034753", "00-0033881", "00-0034975", "00-0036637", "00-0038544", "00-0032392", "00-0040782", "00-0039363", "00-0037112")
```

Left off Judkins (not with team), spears (IR), Likely (not playing, hurt), Daniels (hurt, "00-0039910")
```{r}
Team_Lindsay <- c("00-0039361", "00-0039915", "00-0034351", "00-0037261", "00-0036894", "00-0039851", "00-0023459", "00-0040718", "00-0039342", "00-0038976", "00-0039921", "00-0040179", "00-0039875", "00-0039880", "00-0039746", "00-0040208", "00-0040784", "00-0037238", "00-0039910")
```

Left off Rashee Rice (suspended), Jaxson Dart (not playing), will howard (IR), Jalen Royals (out)
```{r}
Team_Klein_Diel <- c("00-0039150", "00-0039139", "00-0040666", "00-0036554", "00-0040124", "00-0040128", "00-0040129", "00-0039849", "00-0039918", "00-0040730", "00-0040162", "00-0039847", "00-0040142", "00-0040736", "00-0040584", "00-0040236", "00-0037801", "00-0035662", "00-0040727", "00-0035208", "00-0035208", "00-0037617", "1-R-QB3")
```

Left out mixon, godwin (IR for both), should delete BRob, james connor, terrance ferguson (not playing, ""1-R-TE2"), aaron jones (IR, 00-0033293"), Devin Neal and James jordan (not playing, "1-R-RB5", "1-R-RB4"), george kittle (hurt, 00-0033288")
james conner ("00-0033553")
```{r}
Team_Wu <- c("00-0035228", "00-0035261", "00-0039075", "00-0037744", "00-0033040", "00-0036971", "00-0036212", "00-0035719", "00-0035685", "00-0034960", "00-0037267", "00-0031588", "00-0038555", "00-0034383", "00-0037263", "00-0037746", "00-0040719", "00-0035700", "00-0038997")
```

Left out Shough, purdy (hurt, "00-0037834"), added mac jones ("00-0036972), left out jauan jennings (injury, ""00-0036259"), mariota (""00-0032268"), darren waller "00-0031610"
```{r}
Team_McClowry <- c("00-0034844", "00-0032764", "00-0036963", "00-0035640", "00-0038041", "00-0037840", "00-0033908", "00-0033106", "00-0036919", "00-0039919", "00-0038129", "00-0036309", "00-0033090", "00-0036040", "00-0037837", "00-0037256", "00-0040583", "00-0039066", "00-0039066", "00-0035243", "00-0037834", "00-0036259")
```

```{r}
Rookie_team <- c("00-0040126", "00-0040128", "00-0040129", "00-0040676", "00-0040734", "00-0040667", "00-0040730", "00-0040122", "00-0040666", "00-0040124")
```

```{r}
ff %>% filter(player_id %in% Team_Downing) %>% distinct(player_id, .keep_all = TRUE) %>% view()
```

optimal <- optimize_teams(sim_two(ff, Team_Hamm, Team_Wu))

```{r}
names_and_ids %>%
  filter(player_id %in% Rookie_team) %>%
  distinct(player_id, .keep_all = TRUE)
```


for some reason, rookie dudes didn't load into ff. gotta see why. 
