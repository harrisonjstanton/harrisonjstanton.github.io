---
title: "Best Ball Win prob/projection"
author: "Harrison Stanton"
date: "2025-01-07"
output: html_document
---
 
Jake Tonges not showing up in ff

To do list (9/20)
1. Change from 4 quantiles just to upper and lower (1st and 99th?)
2. continue to be diligent on updating rosters. this is really going to affect my projections, even more than Sleeper's
3. Work on the app!!
4. Continue to investigate where my projections fall short that Sleeper's don't
5. Add the 50% after 4 games, 50% over next 8 for rookies
6. add in something so I can't run the sim_two function if a team name is wrong or if no players are in the team 
7. Check how rookies not in that sample look (like kyle williams)

For next year:
1. backtest adding 2025 weighted so I don't have to manually tweak so many players (like Travis Kelce, Jonathan Taylor, etc)
```{r, message=FALSE}
library(tidyverse)
library(dplyr)
library(rsconnect)
library(kableExtra)
library(nflfastR)
library(nflreadr)
library(stats)
library(Hmisc)
library(readr)
library(scales)
```


```{r, message=FALSE}
load("All_Players_Database.RData")
load("RookieDatabase.RData")
Rookie_database <- Rookie_database %>% arrange(full_name)
```

#Data cleaning
Think this is where I was losing my dummy rookie players. just changed na.rm to false instead of true.
This is going to be annoying as crap trying to figure out how to keep my dummy rookies in this list. I feel like the easiest thing might just be to add the mean score for each bucket as their average, but that's going to change all the time. 

This should fix the rookie placeholder stuff
```{r}
Rookie_database <- Rookie_database %>%
  group_by(position, bucket) %>%
  mutate(
    deviation = sd(total_fantasy_points, na.rm = TRUE),
    mean = mean(total_fantasy_points, na.rm = TRUE)
  ) %>%
  ungroup() %>%
  filter(
    is.na(total_fantasy_points) |
    (total_fantasy_points <= mean + 3 * deviation &
     total_fantasy_points >= mean - 3 * deviation &
     total_fantasy_points >= 0)
  )
```


#adding bucket to/pick to ff
Potentially change slide_head to 16 instead (if they're in a championship, i only want this season stats.)
```{r}
ff <- All_Players_Database %>% 
  filter(season == "2023" | season == "2025" | season == "2024" | season == "0") %>%
  group_by(player_id) %>%
  arrange(desc(season), desc(week)) %>%
  #17?
  slice_head(n=16) %>%
  ungroup()
```

```{r}
ff <- ff %>%
  group_by(player_id) %>%
  mutate(
    deviation = sd(total_fantasy_points, na.rm = TRUE),
    mean = mean(total_fantasy_points, na.rm = TRUE)
  ) %>%
  ungroup()
```


```{r}
ff <- ff %>%
  filter((is.rookie == FALSE & total_fantasy_points <= mean + 3 * deviation & total_fantasy_points >= mean - 3 * deviation) | is.rookie == TRUE | is.na(deviation) & !is.na(mean))
```




#Adding bucket to ff
This is very important still, i can't just take this off. ff is being used when i pass into the sim_two, which needs bucket
```{r}
temp <- Rookie_database %>%
  distinct(player_id, .keep_all = TRUE) %>%
  select(player_id, bucket)
```


```{r}
ff <- left_join(ff, temp, by = "player_id")
```

Included this so I didn't double count rookie's scores when generating the weighted quantile
```{r}
Rookie_database <- Rookie_database %>%
  filter(season != 2025)
```



#ChatGPT weighted quantile
```{r}
weighted_quantile <- function(x, w, probs = c(0.25, 0.5, 0.75)) {
  # Remove NAs
  keep <- !is.na(x) & !is.na(w)
  x <- x[keep]
  w <- w[keep]

  # Sort x and w by x
  ord <- order(x)
  x <- x[ord]
  w <- w[ord]

  # Normalize weights
  w <- w / sum(w)
  cum_w <- cumsum(w)

  # Interpolate
  sapply(probs, function(p) {
    if (p <= cum_w[1]) return(x[1])
    if (p >= cum_w[length(cum_w)]) return(x[length(x)])
    idx <- which(cum_w >= p)[1]
    if (cum_w[idx] == p || idx == 1) {
      return(x[idx])
    } else {
      x1 <- x[idx - 1]
      x2 <- x[idx]
      w1 <- cum_w[idx - 1]
      w2 <- cum_w[idx]
      # Linear interpolation
      return(x1 + (p - w1) / (w2 - w1) * (x2 - x1))
    }
  })
}
```


code to view my projections

The projections that seem to always be the most off are rookies and old guys who changed roles.
Is my way of projecting rookies even better? or should I really just have this sucker weight rookie scores way more than it does? Like maybe even by game 3 have like 2/3 weighted to rookies? but then the malik nabers huge game still is a problem. Or could i just have it be like 2/3 weight the whole time, and then just a jump after like 6 games to like 90% that player's scores, then 100% after 12
  - Think this sounds right tbh. Test this tonight. 
```{r}
avg <- scores %>%
  filter(player_id %in% Team_Kloth) %>%
  group_by(player_id) %>%
  summarise(
    lin_avg = mean(score)
  ) %>%
  inner_join(ff %>% select(player_id, full_name) %>% distinct(player_id, .keep_all = TRUE), by = "player_id") %>%
  arrange(full_name) %>%
  view()
```


#Simulate two with non-rookie, <12 GP distinction
This works correctly 9/4
Changed this on 9/18 to weight rookie scores more heavily early on. made it 40% over the first 4. This still isn't perfect (ex. matthew golden too high, colston loveland too high) but from an eye test for rookies it definitely looks better.

Another thought that I had was if they hadn't played yet in 2025 minus QBs and Chris Godwin, what if I docked their potential scores by 90%? Then teams like Luke's wouldn't be so dumb and over project.
Jordan Mason, Trey Benson, Emari Demercado (need to add demarcado to this, michael carter too)

Score * 1.75
```{r}
increased_roles <- c(
  #Kimani Vidal
  "00-0039391",
  #Hassan Haskins
  "00-0037617",
  #Trey Benson
  "00-0039921", 
  #Emari Demercado
  "00-0038705",
  #Michael Carter
  "00-0036924",
  #Sean Tucker
  "00-0038951"
  )
```

Bengals, backup QB (* .8)
CHANGE THIS AFTER LIKE WEEK 5 OF BROWNING. CAN'T DEDUCT ONCE SAMPLE IS BIGGER
```{r}
bengals <- ff %>%
  filter(season == 2025) %>%
  filter(posteam %in% c("CIN")) %>%
  distinct(player_id, .keep_all = FALSE) %>%
  pull(player_id)
```

```{r}
ravens <- ff %>%
  filter(season == 2025) %>%
  filter(posteam %in% c("BAL")) %>%
  distinct(player_id, .keep_all = FALSE) %>%
  pull(player_id)
```


score * .35
```{r}
decreased_roles <- c(
  #Roschon Johnson
  "00-0039021",
  #DeAndre Hopkins
  "00-0030564",
  #Curtis Samuel
  "00-0033282",
  #NWI
  "00-0036182",
  #Will Dissly
  "00-0034159",
  #Pop Douglas
  "00-0038621",
  #Jordan Whittington
  "00-0039751",
  #Luke Musgrave
  "00-0039144",
  #Brian Robinson
  "00-0037746",
  #Tank Bigsby
  "00-0038555",
  #Adam Thielen
  "00-0030035", 
  #Jonnu Smith
  "00-0033858",
  #Keaton Mitchell
  "00-0038454",
  #Malachi Corley
  "00-0039920",
  #Tim Patrick
  "00-0033375",
  #Roschon Johnson 
  "00-0039021",
  #Isaac Guerendo
  "00-0039363",
  #Taysom Hill
  "00-0033357"
  )
```

score * 0
```{r}
bye_week <- ff %>%
  filter(season == 2025) %>%
  filter(posteam %in% c("MIN", "HOU")) %>%
  distinct(player_id, .keep_all = FALSE) %>%
  pull(player_id)
```

score * 0
Keey an eye on Christian Watson, Ricky Pearsall/Jauan jennings, Terry McLaurin, bucky irving, mike evans, colston loveland, Jalen Coker, Chuba Hubbard
```{r}
injured <- c(
  #Lucas Krull
  "00-0037539",
  #Antonio Gibson
  "00-0036328",
  #Omarion Hampton
  "00-0040666",
  #Darius Slayton
  "00-0035535",
  #Brenton Strange
  "00-0038935",
  #Brock Bowers
  "00-0039338",
  #Bucky Irving
  "00-0039361",
  #James Conner
  "00-0033553", 
  #Colston Loveland
  # "00-0040126",
  #Jayden Reed
  "00-0039146",
  #Jalen Coker
  "00-0039491",
  #Lamar Jackson
  "00-0034796",
  #Tank Dell
  "00-0038977", 
  #Malik Nabers
  "00-0039337", 
  #J.J. McCarthy
  "00-0039923",
  #Joe Burrow
  "00-0036442", 
  #Mike Evans
  "00-0031408",
  #Brandon Aiyuk
  "00-0036261",
  #Christian Watson
  "00-0038124",
  #Aaron Jones
  "00-0033293",
  #Braelon Allen
  "00-0039794",
  #Joe Mixon
  "00-0033897",
  #Tyreek Hill
  "00-0033040",
  #George Kittle
  "00-0033288",
  #Ja'Tavion Sanders
  "00-0039356",
  #Ja'Lynn Polk
  "00-0039907",
  #Trey Benson
  "00-0039921",
  #Ricky Pearsall
  "00-0039916",
  #Cedric Tillman
  "00-0038979",
  #Brock Purdy
  "00-0037834",
  #Darnell Mooney
  "00-0036309",
  #MarShawn Lloyd
  "00-0039811",
  #Najee Harris
  "00-0036893",
  #CeeDee Lamb
  "00-0036358",
  #Jonathon Brooks
  "00-0039344",
  #Jalen McMillan
  "00-0039855",
  #Jauan Jennings
  "00-0036259",
  #Chuba Hubbard
  # "00-0036555",
  #Terry McLaurin
  "00-0035659"
  )
```

score * 0
```{r}
suspended <- c(
  #Rashee Rice
  "00-0039067"
)
```

monitor Joe Flaco vs. Jake Browning for who is starting.
score * 0
```{r}
backup_qbs <- c(
  #Anthony Richardson
  "00-0039164",
  #Jalen Milroe
  "00-0040673",
  #Russell Wilson
  "00-0029263",
  #Kirk Cousins
  "00-0029604",
  #Marcus Mariota
  "00-0032268",
  #Tyrod Taylor
  "00-0028118",
  #Jake Browning
  "00-0035100",
  #Jameis Winston
  "00-0031503"
)
```




This is close but not quite there with adding in user created players. I don't know why it doesn't work to be honest, I need to figure that out. I got an error about columns in the tibble not being the same length. commented everything that I added out and it works as intended that way, so I at least didn't break anything. Going to have to do some investigation though.
```{r}
sim_two <- function(ff, team_1, team_2){
  player_ids_vector <- c()
  all_player_scores_list <- list()
  ff <- ff %>%
    select(season, week, full_name, player_id, season_player_id, full_name, position, total_fantasy_points, is.rookie, GP, bucket) %>%
    arrange(full_name)
  
  #I think I need to filter out my added IDs right here. otherwise, 
  player_lookup <- ff %>%
    distinct(player_id, .keep_all = TRUE) %>%
    select(player_id, position, full_name)
  
  subset_df <- ff %>%
    filter(player_id %in% c(team_1, team_2)) 
  
  ids <- c(team_1, team_2)
  
  #keeping user created players
  user_created_players <- ids[grepl("WR,|RB,|TE,|QB,", ids)]
  user_created_players <- tibble(raw = user_created_players) %>%
    mutate(
      team = ifelse(raw %in% Team_1, "Team 1", "Team 2")
    ) %>%
    extract(raw, into = c("position", "score"),
            regex = "([^,]+), ([0-9]+) pts",
            convert = TRUE)


  
  #filtering out user created players from ids
  ids <- ids[!grepl("WR,|RB,|TE,|QB,", ids)]
  
  #think this is the line where I'm getting the error. Actually makes a lot of sense. think I need to filter out added players from each individual team as well, not just from ids. that should make this work. something like:
  team_1 <- team_1[!grepl("WR,|RB,|TE,|QB,", team_1)]
  team_2 <- team_2[!grepl("WR,|RB,|TE,|QB,", team_2)]
  teams <- c(rep("Team 1", length(team_1)),
           rep("Team 2", length(team_2)))
  
  player_info <- tibble(player_id = ids, team = teams) %>%
    left_join(player_lookup, by = "player_id")
  
  
  n_obs <- 15000
  
  
  full_ids <- rep(player_info$player_id, each = n_obs)
  full_positions <- rep(player_info$position, each = n_obs)
  full_names <- rep(player_info$full_name, each = n_obs)
  full_observations <- rep(1:n_obs, length(ids))
  
  
  for(i in 1:length(ids)){
    #df with only the one player's stats
    player <- subset_df %>%
      filter(player_id == ids[[i]]) %>%
      arrange(desc(season), desc(week))
    
    is_rookie <- player$is.rookie[1]
    gp_max <- max(player$GP)


    
     if(is_rookie && gp_max < 12){
         player_position <- player$position[1]
         player_bucket <- player$bucket[1]

         #scores from the same position and bucket as the rookie we're looking at
         position_bucket_scores <- Rookie_database %>%
         filter(position == player_position & bucket == player_bucket) %>%
         pull(total_fantasy_points)

         #player's individual scores
         player_scores <- player$total_fantasy_points

         #number of individual's scores
         rookie_games <- length(player_scores)
         #number of just bucket player's scores
         bucket_games <- length(position_bucket_scores)


         #This is implementing piecewise function instead to slow down weight of rookie's scores initially
         #Messing with this quite a bit
        if(gp_max < 8){
           p <- .8
         } else {
           p <- 0.9
         }
         rookie_weights <- rep(p / rookie_games, rookie_games)
         bucket_weights <- rep((1 - p) / bucket_games, bucket_games)
         combined_weights <- c(rookie_weights, bucket_weights)

         #If I change how many quantiles, would have to go right here
         player_quantile <- weighted_quantile(
           c(player_scores, position_bucket_scores),
           combined_weights,
           probs = c(.1, .90)
           )

     #think I'm going to need one more else if loop here to detect if the player is of added score format.
     } else {
          #changed quantile to just 10th and 90th
          player_quantile <- quantile(player$total_fantasy_points, probs = c(.075, .9))
      }
    
      #individual_scores <- numeric(15000)
      rng <- runif(n_obs)
      scores <- numeric(n_obs)
      
              lower <- unname(player_quantile[1])
              upper <- unname(player_quantile[2])
              scores[rng < .075] <- lower
              scores[rng >= .9] <- upper
              mid_idx <- rng >= .075 & rng < .9
              scores[mid_idx] <- lower + (rng[mid_idx] - 0.075) * (upper - lower) / 0.825

      all_player_scores_list[[i]] <- scores
  } 

  
  
  scores <- tibble(
    observation = full_observations,
    player_id = full_ids,
    team = rep(player_info$team, each = n_obs),
    score = unlist(all_player_scores_list),
    full_name = full_names,
    position = full_positions
  )
  
  scores <- scores %>%
    mutate(
      score = 
        case_when(
          player_id %in% decreased_roles ~ score * .35,
          player_id %in% increased_roles ~ score * 1.75,
          player_id %in% c(backup_qbs, injured, suspended, bye_week) ~ score * 0,
          player_id %in% bengals ~ score * .8,
          player_id %in% ravens ~ score * .8,
          #Chris Godwin, Travis Kelce, Zach Ertz
          player_id %in% c("00-0033921", "00-0030506", "00-0030061") ~ score * .8,
          TRUE ~ score
        )
    )
        
  #so clearly this did not have access to the df created inside the function... tough
  scores <- add_score(user_created_players, scores)

  return(scores)
}

```
Think this is better for right now. Obviously, really stupid that this is how I'm accounting for the slower pace and less scoring by just shifting what I'm doing, but this is definitely closer to what is happening than we're seeing from my above model. If i was projecting target share/scoring that would definitely help, but this is my patchwork way of fixing that. should really view player projections for this right now too. 

this looks better, gonna have to tweak some of the numbers, specifically the increased_roles one.
```{r}
 scores3 <- scores %>%
    mutate(
      score = 
        case_when(
          player_id %in% decreased_roles ~ score * .25,
          player_id %in% increased_roles ~ score * 1.75,
          TRUE ~ score
        )
    ) %>%
  filter(player_id %in% c(decreased_roles, increased_roles))
```



#adding players update, two teams
Think I don't want to combine optimize and this. Think I'd just wanna do optimize_teams(add_player()) instead
This is so close to being nice, but I might need them to add a player name or something. Like if you add two WRs right now to the same team, it's gonna break if they both should hit your lineup. How can I make it so that each time you hit this button, it just increases the player_id number? 

ChatGPT vectorized version, IT WORKS!!
```{r}
#helper function for sim_two()
#user_created_players is a dataframe containing a player input by user of shiny app. contains score, position, and which team
#the player is on
#the function returns scores with the user_created_players added on.
add_score <- function(user_created_players, scores) {
  n <- length(user_created_players$score)
  if(n > 0){
    observation <- seq_len(15000)          # stays same size as your original
    fake_id <- as.character(-sample.int(1e9, n))  # one id per row
    
    temp <- tibble(
      player_id = fake_id,
      score     = user_created_players$score,
      team      = user_created_players$team,
      full_name = paste0(user_created_players$position, ", ", user_created_players$score, " pts"),
      position  = user_created_players$position
    )
    
    temp <- cbind(observation, temp)
    scores <- bind_rows(scores, temp)
  }
    return(scores)
}
```



Workflow: Run both chunks where I have commented in the top of sim_two(). Then need to remove these user_added_players from team1, team2 (just use same grepl, but !grepl()). Then, run add scores after scores is already created, return that sucker

*IMPORTANT*
team1[!grepl("WR,|RB,|TE,|QB,", team1)] - Code to run on team1 and team2 to remove user added stuff. 


ChatGPT vectorized version.
df <- df[, c(3, 1, 2)]
This line of code reorders columns by index (df now is column 3, then 1, then 2). Will need to do this before I try and join the user added one and the one I create in sim v2
```{r}
#keeping user created players
user_created_players <- ids[grepl("WR,|RB,|TE,|QB,", ids)]
user_created_players <- tibble(raw = user_created_players) %>%
  mutate(
    team = ifelse(raw %in% Team_1, "Team 1", "Team 2")
  ) %>%
  extract(raw, into = c("position", "score"),
          regex = "([^,]+), ([0-9]+) pts",
          convert = TRUE)

#filtering out user created players from ids
ids <- ids[!grepl("WR,|RB,|TE,|QB,", ids)]
```



This is by far the slowest part, but idk if there's a better way to do this tbh. 
```{r}
optimize_teams <- function(scores) {


  df <- scores %>%
    arrange(observation, desc(score))
  

  df <- df %>%
    group_by(observation, team) %>%
    mutate(
      qb_rank = cumsum(position == "QB"),
      rb_rank = cumsum(position == "RB"),
      wr_rank = cumsum(position == "WR"),
      te_rank = cumsum(position == "TE")
    ) %>%
    ungroup()
  

  starters <- df %>%
    filter(
      (position == "QB" & qb_rank <= 1) |
      (position == "RB" & rb_rank <= 2) |
      (position == "WR" & wr_rank <= 2) |
      (position == "TE" & te_rank <= 1)
    )
  
  picked_ids <- starters %>% select(observation, team, player_id)
  

  flex <- df %>%
    filter(position %in% c("RB", "WR", "TE")) %>%
    anti_join(picked_ids, by = c("observation", "team", "player_id")) %>%
    group_by(observation, team) %>%
    slice_head(n = 2) %>%
    ungroup()
  
  picked_ids <- bind_rows(picked_ids, flex %>% select(observation, team, player_id))
  
  superflex <- df %>%
    anti_join(picked_ids, by = c("observation", "team", "player_id")) %>%
    group_by(observation, team) %>%
    slice_head(n = 1) %>%
    ungroup()
  

  optimized_team <- bind_rows(starters, flex, superflex) %>%
    arrange(observation, team, desc(score)) %>%
    select(observation, player_id, team, score, full_name, position)
  

  obs_totals <- optimized_team %>%
    group_by(observation, team) %>%
    summarise(total = sum(score, na.rm = TRUE), .groups = "drop") %>%
    pivot_wider(names_from = team, values_from = total) %>%
    mutate(
      winner = if_else(`Team 1` > `Team 2`, "Team 1", "Team 2")
    )
  
  return(obs_totals)
}
```


Code for the labels of the win prob graph. 
```{r}
avg_scores <- obs_totals %>%
  summarise(
    team1_avg = mean(`Team 1`, na.rm = TRUE),
    team2_avg = mean(`Team 2`, na.rm = TRUE)
  )
```



#win prob graph attempt
This looks complete, I'm happy with this.
```{r}
optimal %>%
  count(winner) %>%
  mutate(
    winner = factor(winner, levels = c("Team 2", "Team 1")),
    label_y = ((15000 - n) + .5 * n)/15000
    ) %>%
   ggplot(aes(x = 1, y = n, fill = winner)) +
        geom_bar(stat = "identity", position = "fill") +
        scale_fill_brewer(palette = "Set1",
                          name = "Team") + 
        guides(fill = guide_legend(reverse = TRUE)) +  
        coord_flip() +
        scale_y_continuous(labels = scales::percent_format(accuracy = 1)) +
        labs(x = NULL, title = "Win Probability", y = NULL) +
        theme(
          plot.title = element_text(size = 24, hjust = 0.5),
          axis.title = element_text(size = 18), 
          axis.text.x = element_text(size = 14),
          legend.title = element_text(size = 16), 
          legend.text = element_text(size = 14),
          plot.caption = element_text(size = 14, face = "italic"),
          axis.text.y = element_blank()          
        ) +
        geom_text(aes(y = label_y, label = paste0(round(n/15000, 2) * 100, "%")), color = 'white', size = 5)
```





**IMPORTANT**
If i wanna compare the two like this says, think it might be easiest to just do this in this unpublished shiny app. This way. I can easily just say week < 2 or whatever, and adjust everyone's teams fairly quickly too. 

```{r}
optimal %>%
  count(winner) %>%
  mutate(
    winner = factor(winner, levels = c("Team 2", "Team 1")),
    win_prob = round(n / 15000, 2) * 100,
    #this label y is so broken. need to fix this tomorrow.
    label_y = ((15000 - n) + .5 * n)/15000
    ) 
```



#compare tab
This is what is going to output below the graph in the middle panel.
```{r}
optimal %>%
  summarise(
    Team_1_score = round(mean(`Team 1`)),
    Team_2_score = round(mean(`Team 2`))
  ) 

```




name_list is the players and ids in the same df. Think this is going to need to be a global variable. Want to be able to use this right away when people input teams. 

need to pass vector of names, pull ids, then do the same stuff. think that's easier. going to have to change the UI to include roster, have it be clickable as well.

I want to make this take a vector of player names, not just one player name. If you click 5 ppl and try to remove them all at once, that should work. 
```{r}
#this is something I'm going to need for all the dropdowns as well. Might have to use match, idek how it's all going to work tbh. Need you to be able to input a player name from a dropdown and then have my ish switch to a player_id instead.
remove_player <- function(player_name){
  name_list <- ff %>%
    select(full_name, player_id) %>%
    distinct(player_id, .keep_all = TRUE)
  
  user_id <- name_list %>%
    filter(full_name == player_name) %>%
    pull(player_id)
  
  #this is basically what it's going to be
  scores <- scores %>% 
    filter(player_id != user_id)
  
  return(scores)
}
```

For clearing out stuff if someone straight up just wants to start over
```{r}
clear_all <- function(){
  rm(scores, optimal, team_1, team_2, envir = .GlobalEnv)
}
```

Add player to roster
This should have a dropdown, like a data validation vibe, where you can only put team 1 or team 2
Also, going to have to include team_1 and team_2 in my global environment when I make the app. Basically just that initial dropdown right away have it be team_1 or team_2. probably will have to change the variable names inside the function to something like input$team_1
```{r}
add_player <- function(player, team){
  if(team == "Team 1"){
    team <- team_1
  } else {
    team <- team_2
  }
  team <- c(team, player)
  
  return(team)
}
```


So how would this work as a user? it'd be:
1. select teams
 a. have this immediately generate scores to save time (use the reactive part here)
2. add player scores/remove players
3. optimize -> if at all possible, only run optimize once. this thing takes forever.
4. graph

this is going to take a hot sec to run i'm ngl, but it's gonna be pretty dope when it does

# This is what the app is going to be, maybe plus or minus the add/remove players
I don't think this is the way it should work. optimze + graph + sim should be separated. if i did it like this, then add and remove player wouldn't even work. 

workflow:
1. pick team
2. add or remove players from team
3. simulate
4. add scores from the week
5. optimize + graph (this can be the same step. think that's totally fine.)

Labels on this graph got messed up. Don't know where it went wrong, feel like that might not be a right now problem though. 
```{r}
optimize_teams(scores) %>%
  count(winner) %>%
  mutate(
    winner = factor(winner, levels = c("Team 2", "Team 1")),
    label_y = ((15000 - n) + .5 * n)/15000
    ) %>%
   ggplot(aes(x = 1, y = n, fill = winner)) +
        geom_bar(stat = "identity", position = "fill") +
        scale_fill_brewer(palette = "Set1",
                          name = "Team") + 
        guides(fill = guide_legend(reverse = TRUE)) +  
        coord_flip() +
        scale_y_continuous(labels = scales::percent_format(accuracy = 1)) +
        labs(x = NULL, title = "Win Probability", y = NULL) +
        theme(
          plot.title = element_text(size = 24, hjust = 0.5),
          axis.title = element_text(size = 18), 
          axis.text.x = element_text(size = 14),
          legend.title = element_text(size = 16), 
          legend.text = element_text(size = 14),
          plot.caption = element_text(size = 14, face = "italic"),
          axis.text.y = element_blank()          
        ) +
        geom_text(aes(y = label_y, label = paste0(round(n/15000, 2) * 100, "%")), color = 'white', size = 5)
```


Next steps for my project:
6/30
1. Finish data entry for rookie non stat recording weeks
2. Need to finish rookie quantile projection. Think because of the lack of data, acceptable to eye ball best relationship, definitely wanna use some log slowly increasing function
3. Make linear_sim(), optimize_team() work for 2 teams at once (if they put nothing for team two, pass along empty string and make it a 100% win prob)
4. Make win prob/compare! shouldn't be too bad, especially once linear sim and optimize functions work for both teams
5. Make the shiny app! (How am I gonna do rookies? Wait till week 2?)
6. Make a manual lever to pull for when someone's role dramatically changes, like Raheem Mostert from 2023 to 2024 (points per touch * # of extra touches + projection)

Biggest problems i foresee with my projection:
1. handcuff players 
  what happens when KW3 goes down and my charb projection stays the same? obviously that's not right
      Best guess right now: add a term - fp/touch * normal dist centered around touches vacqted. going to have to
      manually input for guys (i think i can guesstimate how a backfield is gonna be split than actually have 
      a mathematical reasoning behind it)
        - need to test using 2023 data on 2024 season. 
2. rookies
  what happens when 3 games into the season, it's obvious that BTJ and Ladd are better than their quadrant but I'm still
  grouping by their draft capital? Is there some way I can weight recent production more than the past, especially for 
  young guys? 
    Hmisc:wtd.quantile() - weight the persons scores equally to the scores of rookies in the same bucket. I think this
    will be a much more effective way to estimate their scores, but I'm gonna try it using 2023 data on 2024
    season to see what the best method is

**Important**
When I'm telling everyone how to use this, need to make sure that they don't add a bunch of ppl who are hurt/backup QBs. If they're not gonna play, just don't add them. I don't have time to update them all every week, but I'll update handcuff running backs and stuff like that where I can

Going to need a remove player from list function, and also a clear_all function for the shiny app.


Linear sim only gonna work for full team... observation numbers get messed up otherwise. 3 observations for each player when I used the 

#making objects for the app
This should probably be saved for all the lists/dropdowns
```{r}
names_and_ids <- All_Players_Database %>%
  filter(season %in% c(0, 2025, 2023, 2024)) %>%
  filter(position %in% c("QB", "WR", "TE", "RB")) %>%
  arrange(desc(total_fantasy_points)) %>%
  select(full_name, player_id) %>%
  filter(!is.na(full_name))
```

How I want to display each team. Have them all stored as their IDs, but then just keep everything in terms of names using names_and_ids
```{r}
names_and_ids %>%
  filter(player_id %in% Jared_alt) %>%
  pull(full_name)
```

#teams
Jarquez Hunter (not playing) 
```{r}
Team_Stanton <- c("00-0036389", "00-0039893", "00-0038543", "00-0037809", "00-0036912", "00-0037816", "00-0036264", "00-0040734", "00-0040676", "00-0040126", "00-0037545", "00-0040663", "00-0040648", "00-0038951", "00-0040131", "00-0040138", "00-0039798", "00-0039491", "00-0039811", "00-0039146", "00-0040719", "00-0040704", "00-0038797", "00-0038454")
```


```{r}
Team_Johnson <- c("00-0039732", "00-0036555", "00-0040242", "00-0036322", "00-0039337", "00-0038933", "00-0037740", "00-0039894", "00-0035710", "00-0039376", "00-0039901", "00-0038935", "00-0036139", "00-0040739", "00-0039868", "00-0032950", "00-0033662", "00-0040729", "00-0040715", "00-0040242", "00-0039874", "00-0039923", "00-0038611", "00-0040078", "00-0033246", "00-0037004")
```


```{r}
Team_Snyder <- c("00-0034857", "00-0040122", "00-0038134", "00-0035676", "00-0036410", "00-0039338", "00-0039064", "00-0034796", "00-0037228", "00-0036997", "00-0034829", "00-0036970", "00-0036626", "00-0040735", "00-0040669", "00-0035644", "00-0039355", "00-0038705", "00-0040189", "00-0038994", "00-0032385", "00-0038977", "00-0039384", "00-0038440", "00-0039410")
```


```{r}
Team_Kloth <- c("00-0036442", "00-0038542", "00-0038597", "00-0034775", "00-0031408", "00-0036252", "00-0035229", "00-0039040", "00-0038120", "00-0034855", "00-0030565", "00-0037239", "00-0038996", "00-0030279", "00-0038608", "00-0036875", "00-0037664", "00-0038117", "00-0040170", "00-0038563", "00-0035100", "00-0030035", "00-0038606", "00-0036261", "00-0037005")
```

Leaving out ARich, milroe, kirk add them back in if they play
need to change Roman Wilson, JJ McCarthy rookie years to now for calculation purposes. 

left out milroe ("00-0040673"), 
```{r}
Team_Weiner <- c("00-0033077", "00-0033906", "00-0036158", "00-0036407", "00-0030506", "00-0036613", "00-0036973", "00-0026498", "00-0034869", "00-0030061", "00-0037525", "00-0033923", "00-0033858", "00-0039794", "00-0040164", "00-0038393", "00-0038555", "00-0033293", "00-0036893", "00-0036358", "00-0029263", "00-0038124", "00-0029604", "00-0039164")
```

FIGURE OUT JOE MILTON. Malachi Corley too
Roschon (00-0039021)
```{r}
Team_Chesney <- c("00-0039163", "00-0034791", "00-0034827", "00-0037240", "00-0036290", "00-0039916", "00-0037247", "00-0038979", "00-0040130", "00-0030564", "00-0039793", "00-0033282", "00-0034159", "00-0037666", "00-0033375", "00-0034407", "00-0037741", "00-0036328", "00-0036182", "00-0033857", "00-0037539", "00-0031503", "00-0039920", "00-0039021")
```

Quinn Ewers, JIMMY HORN, shough, mullings (haven't played)
```{r}
Team_Hamm <- c("00-0036355", "00-0040198", "00-0038551", "00-0040667", "00-0039065", "00-0039356", "00-0038621", "00-0036550", "00-0036988", "00-0040581", "00-0039751", "00-0039144", "00-0040644", "00-0040134", "00-0039890", "00-0040009", "00-0038104", "00-0039907", "00-0040582", "00-0039344", "00-0039855")
```

Left off Sheduer (not gonna play),
```{r}
Team_Downing <- c("00-0033873", "00-0033280", "00-0036223", "00-0036900", "00-0033885", "00-0037248", "00-0034348", "00-0026158", "00-0039917", "00-0031381", "00-0034837", "00-0037197", "00-0036275", "00-0034753", "00-0033881", "00-0034975", "00-0036637", "00-0038544", "00-0040782", "00-0039363", "00-0037112", "00-0036945", "00-0035659", "00-0028118")
```


```{r}
Team_Lindsay <- c("00-0039361", "00-0039915", "00-0034351", "00-0037261", "00-0036894", "00-0039851", "00-0023459", "00-0040718", "00-0039342", "00-0038976", "00-0039921", "00-0040179", "00-0039875", "00-0039880", "00-0039746", "00-0040208", "00-0040784", "00-0037238", "00-0039032", "00-0037838", "00-0039910", "00-0035250", "00-0040184", "00-0037267", "00-0040586")
```

will howard (IR), Jalen Royals (out)
```{r}
Team_Klein_Diel <- c("00-0039150", "00-0039139", "00-0040666", "00-0036554", "00-0040124", "00-0040128", "00-0040129", "00-0039849", "00-0039918", "00-0040730", "00-0040162", "00-0039847", "00-0040142", "00-0040736", "00-0040236", "00-0037801", "00-0035662", "00-0040727", "00-0035208", "00-0035208", "00-0035535", "00-0040691", "00-0039067", "00-0039391")
```

TERRANCE FERGUSON NOT IN DF, SHOULD BE (not playing, ""1-R-TE2")
```{r}
Team_Wu <- c("00-0035228", "00-0035261", "00-0039075", "00-0037744", "00-0033040", "00-0036971", "00-0036212", "00-0035719", "00-0035685", "00-0034960", "00-0031588", "00-0034383", "00-0037263", "00-0037746", "00-0035700", "00-0038997", "00-0039165", "00-0033553", "00-0033288", "00-0033921", "00-0033897", "00-0031610", "00-0033307", "00-0033357")
```

Left off Gus Edwards (not on an NFL roster)
```{r}
Team_McClowry <- c("00-0034844", "00-0032764", "00-0036963", "00-0035640", "00-0038041", "00-0037840", "00-0033908", "00-0033106", "00-0036919", "00-0039919", "00-0038129", "00-0036309", "00-0033090", "00-0036040", "00-0037837", "00-0037256", "00-0040583", "00-0039066", "00-0039066", "00-0037834", "00-0036259", "00-0036924", "00-0036972", "00-0039738", "00-0037617")
```

```{r}
Rookie_team <- c("00-0040126", "00-0040128", "00-0040129", "00-0040676", "00-0040734", "00-0040667", "00-0040730", "00-0040122", "00-0040666", "00-0040124")
```

```{r}
ff %>% filter(player_id %in% Team_Kloth) %>% distinct(player_id, .keep_all = TRUE) %>% view()
```

optimal <- optimize_teams(sim_two_v2(ff, Team_Hamm, Team_Wu))

```{r}
names_and_ids %>%
  filter(player_id %in% Rookie_team) %>%
  distinct(player_id, .keep_all = TRUE)
```

```{r}
list(Team_Chesney, Team_Downing)
```

for some reason, rookie dudes didn't load into ff. gotta see why. 

```{r}
save(ff, backup_qbs, bye_week, bengals, names_and_ids, decreased_roles, increased_roles, injured, suspended, Team_Chesney, Team_Downing, Team_Hamm, Team_Johnson, Team_Klein_Diel, Team_Kloth, Team_Lindsay, Team_McClowry, Team_Snyder, Team_Stanton, Team_Weiner, Team_Wu, add_player, add_score, clear_all, optimize_teams, sim_two, weighted_quantile, file = "BestBallDfs.RData")
```

